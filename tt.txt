# Import required packages
import os
import json
from flask import Flask, request, abort
from linebot.v3 import WebhookHandler
from linebot.v3.messaging import Configuration, ApiClient, MessagingApi
from linebot.v3.webhooks import MessageEvent, TextMessageContent
from linebot.v3.messaging import TextMessage
from linebot.v3.exceptions import InvalidSignatureError
from google.cloud.dialogflow_v2 import SessionsClient
from google.cloud.dialogflow_v2.types import TextInput, QueryInput

# Create a json file for Dialogflow Credentials
# IMPORTANT: แทนที่ด้วย path ที่เหมาะสมบนเซิร์ฟเวอร์
credential_path = "/path/to/your/bru-edubot-bhbk-bffde9b648b0.json"

# Dialogflow Configuration
os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = credential_path
DIALOGFLOW_PROJECT_ID = "bru-edubot-bhbk"
SESSION_ID = "line-bot-session"

# LINE Configuration
LINE_CHANNEL_ACCESS_TOKEN = 'd8D1X3sR/9fXo+t0hZtOlvnGn7UG6IYQ9JFMjLIRejqba2jdYdbbzDL/XgiA/le11FZ6nhpfQDifFGvPMtZ66guE6qy4wu6UVEgFFz59JNSSQCTY7jbFCKdAtN0SKpI//KA6jqOXsrkzeeqmOkLzHgdB04t89/1O/w1cDnyilFU='
LINE_CHANNEL_SECRET = '1400eed767cba4b4158339854c6008c2'

app = Flask(__name__)

# Setup LINE API client using v3
configuration = Configuration(access_token=LINE_CHANNEL_ACCESS_TOKEN)
handler = WebhookHandler(LINE_CHANNEL_SECRET)
api_client = ApiClient(configuration)
line_bot_api = MessagingApi(api_client)

@app.route("/callback", methods=['POST'])
def callback():
    # Get X-Line-Signature header value
    signature = request.headers['X-Line-Signature']

    # Get request body as text
    body = request.get_data(as_text=True)
    app.logger.info("Request body: %s", body)

    try:
        handler.handle(body, signature)
    except InvalidSignatureError:
        app.logger.error("Invalid signature")
        abort(400)

    return 'OK'

@handler.add(MessageEvent, message=TextMessageContent)
def handle_message(event):
    user_id = event.source.user_id
    text_from_user = event.message.text
    
    # เช็คว่าเป็นข้อความจากกลุ่มหรือไม่
    is_group = False
    if hasattr(event.source, 'type'):
        if event.source.type == 'group':
            is_group = True
        elif event.source.type == 'room':  # MultiPerson chat room
            is_group = True
    
    # กำหนดชื่อบอทที่จะใช้ (สามารถเปลี่ยนเป็นชื่อของบอทคุณ)
    bot_name = "edubot"  # เปลี่ยนเป็นชื่อบอทที่คุณต้องการ
    
    # หากเป็นข้อความในกลุ่ม ตรวจสอบว่ามีการ @ ชื่อบอทหรือไม่
    should_respond = False
    actual_message = text_from_user
    
    if is_group:
        # ตรวจสอบว่าข้อความเริ่มต้นด้วย @ ตามด้วยชื่อบอทหรือไม่
        if text_from_user.startswith(f'@{bot_name}'):
            # แยกส่วนข้อความหลังจากชื่อบอท
            try:
                # หาตำแหน่งของชื่อบอทใน mention
                mention_part = f'@{bot_name}'
                message_start = text_from_user.find(mention_part) + len(mention_part)
                actual_message = text_from_user[message_start:].strip()
                should_respond = True
            except:
                # กรณีที่มีการ mention แต่อาจมีรูปแบบไม่ถูกต้อง
                actual_message = ""
                should_respond = True
    else:
        # ถ้าเป็นการแชทส่วนตัว ให้ตอบเสมอ
        should_respond = True
    
    # ถ้าควรตอบ ให้ประมวลผลข้อความและตอบกลับ
    if should_respond:
        # ถ้าข้อความว่างเปล่าแต่มีการ mention บอท
        if not actual_message and should_respond:
            reply_text = f"สวัสดีครับ ผมคือ {bot_name} คุณต้องการสอบถามอะไรครับ?"
        else:
            # สร้าง session ID สำหรับผู้ใช้แต่ละคน
            user_session_id = f"{SESSION_ID}-{user_id}"
            
            # ส่งข้อความไปยัง Dialogflow
            response = detect_intent_texts(DIALOGFLOW_PROJECT_ID, user_session_id, actual_message, 'th')
            
            # ดึงข้อความตอบกลับจาก Dialogflow
            reply_text = response.query_result.fulfillment_text
            
            # ถ้าไม่มีการตอบกลับจาก Dialogflow ให้ใช้ข้อความเริ่มต้น
            if not reply_text:
                reply_text = "ขออภัย ฉันไม่เข้าใจคำถามของคุณ กรุณาถามใหม่อีกครั้ง"
        
        # ตอบกลับผู้ใช้ผ่าน LINE Messaging API
        line_bot_api.reply_message(
            reply_message_request={
                "replyToken": event.reply_token,
                "messages": [TextMessage(text=reply_text)]
            }
        )

def detect_intent_texts(project_id, session_id, text, language_code):
    """Detect intent using Dialogflow API"""
    try:
        session_client = SessionsClient()
        session = session_client.session_path(project_id, session_id)

        text_input = TextInput(text=text, language_code=language_code)
        query_input = QueryInput(text=text_input)

        response = session_client.detect_intent(
            request={"session": session, "query_input": query_input}
        )
        return response
    except Exception as e:
        app.logger.error(f"เกิดข้อผิดพลาดในการเชื่อมต่อกับ Dialogflow: {str(e)}")
        # สร้างข้อความตอบกลับสำรองในกรณีที่มีข้อผิดพลาด
        class MockResponse:
            class MockQueryResult:
                fulfillment_text = "ขออภัย ระบบกำลังมีปัญหาในการเชื่อมต่อ กรุณาลองใหม่ในภายหลัง"
            query_result = MockQueryResult()
        return MockResponse()

@app.route("/")
def home():
    return "LINE Bot with Dialogflow is running!"

if __name__ == "__main__":
    # เมื่อรันบน production ควรใช้ WSGI server เช่น Gunicorn แทนที่ Flask development server
    # สำหรับการทดสอบบนเครื่องโดยตรง สามารถใช้การรันแบบนี้
    app.run(host='0.0.0.0', port=5000, debug=False)